        const plaques = [
            {
                id: 1,
                title: "Targa 1",
                lat: 40.38686389,
                lng: 9.61706111,
                image: "assets/img/01.jpg?v=1.0.22",
                audio: "",
                missingWords: ["verde", "muraglie", "glauco"],
                blurAreas: [
                    { top: 105, left: 178, width: 51, height: 25 },
                    { top: 150, left: 175, width: 55, height: 25 },
                ],
                radius: 50,
                isLastPlaque: false,
                locationImage: 'assets/img/01_360.jpg?v=1.0.22',
                locationImageLowRes: 'assets/img/01_360_low.jpg?v=1.0.22',
                locationMaskImage: 'assets/img/01_360_mask.png?v=1.0.22',
                locationBlurMaskImage: 'assets/img/01_360_blur.png?v=1.0.22',
                locationBlurMaskSolvedImage: null,
                locationImageSolvedImage: 'assets/img/01_360.jpg?v=1.0.22',
                locationImageSolvedImageLowRes: 'assets/img/01_360_low.jpg?v=1.0.22',
                locationTitle: "Il Rifugio tra le Canne e le Rocce",
                locationDescription: `<p>Nel cuore del borgo, dove batte l‚Äôanima della comunit√†, cercate sulla parete sussurri di pietra.<br/>Qui, al lato della casa di chi amministra il villaggio, riecheggiano le parole di Grazia Deledda: un rifugio verde e antico vi attende.</p>`,
            },{
                id: 2,
                title: "Targa 2",
                lat: 40.38679722,
                lng: 9.61670833,
                image: "assets/img/02.jpg?v=1.0.22",
                audio: "",
                missingWords: ["nascondiglio", "pallido", "fiore"],
                blurAreas: [
                    { top: 20, left: 30, width: 100, height: 50 },
                    { top: 80, left: 120, width: 150, height: 100 }
                ],
                radius: 50,
                isLastPlaque: false,
                locationImage: 'assets/img/02_360.jpg?v=1.0.22',
                locationImageLowRes: 'assets/img/02_360_low.jpg?v=1.0.22',
                locationMaskImage: 'assets/img/02_360_mask.png?v=1.0.22',
                locationBlurMaskImage: 'assets/img/02_360_blur.png?v=1.0.22',
                locationBlurMaskSolvedImage: 'assets/img/02_360_blur_solved.png?v=1.0.22',
                locationSolvedImage: 'assets/img/02_360.jpg?v=1.0.22',
                locationTitle: "Il Cristo che Cammina tra il Popolo",
                locationDescription: `<p>Dove il tempo si raccoglie in preghiera, sorge un luogo antico che custodisce una presenza sacra. Cerca vicino alla chiesa del Santissimo Crocifisso, l√† dove il Cristo dietro la tenda giallastra sembra emergere e camminare tra il popolo. Qui, tra fede e devozione, troverai il prossimo frammento di storia.</p>`,
            },{
                id: 3,
                title: "Targa 3",
                lat: 40.38679444,
                lng: 9.61672778,
                image: "assets/img/03.jpg?v=1.0.22",
                audio: "",
                missingWords: ["sparvero", "solitudine"],
                blurAreas: [
                    { top: 20, left: 30, width: 100, height: 50 },
                    { top: 80, left: 120, width: 150, height: 100 }
                ],
                radius: 50,
                isLastPlaque: false,
                locationImage: 'assets/img/03_360.jpg?v=1.0.22',
                locationImageLowRes: 'assets/img/03_360_low.jpg?v=1.0.22',
                locationMaskImage: 'assets/img/03_360_mask.png?v=1.0.22',
                locationBlurMaskImage: 'assets/img/03_360_blur.png?v=1.0.22',
                locationBlurMaskSolvedImage: null,
                locationSolvedImage: 'assets/img/03_360.jpg?v=1.0.22',
                locationTitle: "Fantasmi nel Silenzio del Villaggio",
                locationDescription: `<p>Di fronte al luogo sacro dove il tempo si ferma, il silenzio avvolge le anime come un velo. Cerca l√† dove le donne scompaiono tacite, come ombre nel paesaggio, lasciando il villaggio immerso nella sua solitudine.</p>`,
            },{
                id: 4,
                title: "Targa 4",
                lat: 40.38626667,
                lng: 9.61484444,
                image: "assets/img/04.jpg?v=1.0.22",
                audio: "",
                missingWords: ["melograni", "case"],
                blurAreas: [
                    { top: 20, left: 30, width: 100, height: 50 },
                    { top: 80, left: 120, width: 150, height: 100 }
                ],
                radius: 50,
                isLastPlaque: false,
                locationImage: 'assets/img/04_360.jpg?v=1.0.22',
                locationImageLowRes: 'assets/img/04_360_low.jpg?v=1.0.22',
                locationMaskImage: 'assets/img/04_360_mask.png?v=1.0.22',
                locationBlurMaskImage: 'assets/img/04_360_blur.png?v=1.0.22',
                locationBlurMaskSolvedImage: null,
                locationSolvedImage: 'assets/img/04_360.jpg?v=1.0.22',
                locationTitle: "Il Paese Fiorito di Melograni",
                locationDescription: `<p>Segui il profumo della vitalba e cerca i melograni che decorano il borgo. In via Cavour, tra case nuove e antichi ricordi, troverai il prossimo frammento che racconta la bellezza nascosta del paese.</p>`,
            },{
                id: 5,
                title: "Targa 5",
                lat: 40.38616389,
                lng: 9.61448889,
                image: "assets/img/05.jpg?v=1.0.22",
                audio: "",
                missingWords: ["pianura", "macchie", "fiume"],
                blurAreas: [
                    { top: 20, left: 30, width: 100, height: 50 },
                    { top: 80, left: 120, width: 150, height: 100 }
                ],
                radius: 50,
                isLastPlaque: false,
                locationImage: 'assets/img/05_360.jpg?v=1.0.22',
                locationImageLowRes: 'assets/img/05_360_low.jpg?v=1.0.22',
                locationMaskImage: 'assets/img/05_360.png?v=1.0.22',
                locationBlurMaskImage: null,
                locationBlurMaskSolvedImage: null,
                locationSolvedImage: 'assets/img/05_360.jpg?v=1.0.22',
                locationTitle: "La Valle che si apre al sole",
                locationDescription: `<p>Nei pressi del museo etnografico, dove la storia incontra la natura, lasciati guidare dal panorama: una valle malinconica dipinta di rosa dal sole nascente, dove il fiume scorre tra giunchetti e sabbie colorate. Qui troverai il prossimo tesoro.</p>`,
            },{
                id: 6,
                title: "Targa 6",
                lat: 40.38695000,
                lng: 9.61763611,
                image: "assets/img/06.jpg?v=1.0.22",
                audio: "",
                missingWords: ["casa", "cortile", "monte"],
                blurAreas: [
                    { top: 20, left: 30, width: 100, height: 50 },
                    { top: 80, left: 120, width: 150, height: 100 }
                ],
                radius: 50,
                isLastPlaque: false,
                locationImage: 'assets/img/06_360.jpg?v=1.0.22',
                locationImageLowRes: 'assets/img/06_360_low.jpg?v=1.0.22',
                locationMaskImage: 'assets/img/06_360.png?v=1.0.22',
                locationBlurMaskImage: null,
                locationBlurMaskSolvedImage: null,
                locationSolvedImage: 'assets/img/06_360.jpg?v=1.0.22',
                locationTitle: "La Casa ai piedi del monte",
                locationDescription: `<p>Sulla parete della casa delle "Dame di Pintor", cerca l'abitazione semplice ma maestosa: una dimora che, al di l√† del cortile, √® vegliata dall'imponente presenza del monte. L√¨ troverai la risposta</p>`,
            },{
                id: 7,
                title: "Targa 7",
                lat: 40.38696111,
                lng: 9.61824722,
                image: "assets/img/07.jpg?v=1.0.22",
                audio: "",
                missingWords: ["fantasmi", "rovine", "castello"],
                blurAreas: [
                    { top: 20, left: 30, width: 100, height: 50 },
                    { top: 80, left: 120, width: 150, height: 100 }
                ],
                radius: 50,
                isLastPlaque: false,
                locationImage: 'assets/img/07_360.jpg?v=1.0.22',
                locationImageLowRes: 'assets/img/07_360_low.jpg?v=1.0.22',
                locationMaskImage: 'assets/img/07_360.png?v=1.0.22',
                locationBlurMaskImage: null,
                locationBlurMaskSolvedImage: null,
                locationSolvedImage: 'assets/img/07_360.jpg?v=1.0.22',
                locationTitle: "I Fantasmi di Galte",
                locationDescription: `<p>Vicino al cimitero, all‚Äôingresso della chiesa di San Pietro del XII secolo, si racconta che gli antichi baroni, ormai fantasmi, scendano dalle rovine del castello sopra Galte. Qui, tra storia e leggenda, troverai la prossima traccia.</p>`,
            },{
                id: 8,
                title: "Targa 8",
                lat: 40.38623611,
                lng: 9.61560833,
                image: "assets/img/08.jpg?v=1.0.22",
                audio: "",
                missingWords: ["pietra", "velluto"],
                blurAreas: [
                    { top: 20, left: 30, width: 100, height: 50 },
                    { top: 80, left: 120, width: 150, height: 100 }
                ],
                radius: 50,
                isLastPlaque: false,
                locationImage: 'assets/img/08_360.jpg?v=1.0.22',
                locationImageLowRes: 'assets/img/08_360_low.jpg?v=1.0.22',
                locationMaskImage: 'assets/img/08_360.png?v=1.0.22',
                locationBlurMaskImage: null,
                locationBlurMaskSolvedImage: null,
                locationSolvedImage: 'assets/img/08_360.jpg?v=1.0.22',
                locationTitle: "L‚Äôuomo sulla panchina di pietra",
                locationDescription: `<p>In via Savoia, immagina la panchina di pietra e un grosso uomo vestito di velluto, seduto l√¨ come un custode silenzioso del tempo. √à qui che troverai il prossimo indizio.</p>`,
            },{
                id: 9,
                title: "Targa 9",
                lat: 40.38809722,
                lng: 9.61807778,
                image: "assets/img/09.jpg?v=1.0.22",
                audio: "",
                missingWords: ["cortili", "strade"],
                blurAreas: [
                    { top: 20, left: 30, width: 100, height: 50 },
                    { top: 80, left: 120, width: 150, height: 100 }
                ],
                radius: 50,
                isLastPlaque: false,
                locationImage: 'assets/img/09_360.jpg?v=1.0.22',
                locationImageLowRes: 'assets/img/09_360_low.jpg?v=1.0.22',
                locationMaskImage: 'assets/img/09_360.png?v=1.0.22',
                locationBlurMaskImage: null,
                locationBlurMaskSolvedImage: null,
                locationSolvedImage: 'assets/img/09_360.jpg?v=1.0.22',
                locationTitle: "Tra Ruderi e Memorie",
                locationDescription: `<p>In via 'Nonnu Marras', lasciati guidare dai segni del passato: muri sgretolati, cupole senza tetto e catapecchie che raccontano storie malinconiche. Qui, tra i ruderi e ci√≤ che resta, troverai il prossimo indizio.</p>`,
            },{
                id: 10,
                title: "Targa 10",
                lat: 40.38761667,
                lng: 9.61888056,
                image: "assets/img/10.jpg?v=1.0.22",
                audio: "",
                missingWords: ["monte", "cimitero", "basilica"],
                blurAreas: [
                    { top: 20, left: 30, width: 100, height: 50 },
                    { top: 80, left: 120, width: 150, height: 100 }
                ],
                radius: 50,
                isLastPlaque: false,
                locationImage: 'assets/img/10_360.jpg?v=1.0.22',
                locationImageLowRes: 'assets/img/10_360_low.jpg?v=1.0.22',
                locationMaskImage: 'assets/img/10_360.png?v=1.0.22',
                locationBlurMaskImage: null,
                locationBlurMaskSolvedImage: null,
                locationSolvedImage: 'assets/img/10_360.jpg?v=1.0.22',
                locationTitle: "L‚ÄôAntica Basilica e il Cimitero Perduto",
                locationDescription: `<p>All‚Äôingresso della chiesa di San Pietro, cerca l‚Äôombra del monte, tra siepi di rovi ed euforbia. Qui giacciono i resti di un antico cimitero e della maestosa basilica pisana che custodisce i segreti del tempo. √à in questo luogo che troverai il tuo ultimo indizio.</p>`,
            },{
                id: 11,
                title: "Congratulazioni",
                lat: 40.38082222,
                lng: 9.63780000,
                image: "assets/img/11_360.jpg?v=1.0.22",
                audio: "data:audio/mpeg;base64,//uQZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAAFAAABLgAAAgAICQoLDQ8REhMVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4CBgoOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLm6u7y9vr/AwcLDxMXGx8jJysvMzc7P0NHSo6PmAQA7",
                missingWords: [],
                blurAreas: [
                    { top: 20, left: 30, width: 100, height: 50 },
                    { top: 80, left: 120, width: 150, height: 100 }
                ],
                radius: 50,
                isLastPlaque: true,
                locationImage: 'assets/img/11_360.jpg?v=1.0.22',
                locationImageLowRes: 'assets/img/11_360_low.jpg?v=1.0.22',
                locationMaskImage: 'assets/img/11_360.png?v=1.0.22',
                locationBlurMaskImage: null,
                locationBlurMaskSolvedImage: null,
                locationSolvedImage: 'assets/img/11_360.jpg?v=1.0.22',
                locationTitle: "Congratulazioni!",
                locationDescription: `
                    <div class="final-content">
                        <h3>Esploratore Letterario</h3>
                        <p>Hai completato tutte le 10 targhe nascoste!</p>
                        <div class="quote">
                            "E come canne al vento ci curvammo, ma non ci spezzammo:
                            nella tempesta trovammo la nostra voce"
                        </div>
                        <p>Il tuo premio: il discorso integrale di Grazia Deledda per il Nobel</p>
                        <div class="prize-buttons">
                            <button onclick="claimPrize()">üéÅ Ritira il Premio</button>
                            <button onclick="resetGame()">üîÑ Rigioca</button>
                        </div>
                        <p class="nobel-link">
                            Scopri la storia del premio:
                            <a href="https://www.nobelprize.org/prizes/literature/1926/summary/" target="_blank">
                                Discorso Nobel 1926
                            </a>
                        </p>
                    </div>
                `,
            },
            // Aggiungi altre 9 targhe nello stesso formato
        ];

        let map;
        let userProgress = JSON.parse(localStorage.getItem('progress')) || { found: [] };
        let currentPositionMarker;
        let routingControl;
        let userPosition;


        // Ottenere il valore di una variabile CSS (--secondary-color) definita nel :root
        function getCSSVariable(variableName) {
          // Ottiene lo stile computato dall'elemento root
          const rootStyles = getComputedStyle(document.documentElement);

          // Legge il valore della variabile CSS
          return rootStyles.getPropertyValue(variableName).trim();
        }

        function isTouch(event) {
            return (event.touches !== undefined || event instanceof TouchEvent);
        }

        function vibrate(){
            // Aggiunta: Vibrazione quando si tocca un'area interattiva
            if ("vibrate" in navigator) {
                navigator.vibrate(50);  // Vibrazione breve di 50ms
            }
        }

        function resetButtons(){
            document.getElementById('startButton').innerHTML = "Inizia l'Avventura";
            if(userProgress.found.length > 0){
                document.getElementById('startButton').innerHTML = "Continua l'Avventura";
            }
        }

        function init() {
            resetButtons();
            initMap();
            setupEventListeners();
            startWatchingPosition();
            updateMap();
        }

        function initMap() {


            // Inizializzazione mappa
            map = L.map('map').setView([40.7527295, 14.6464048], 14);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?v=1.0.22').addTo(map);

            /*L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Mappa del Tesoro ¬© Letteraria',
            }).addTo(map);*/
            L.Routing.control({
                waypoints: [
                    L.latLng(57.74, 11.94),
                    L.latLng(57.6792, 11.949)
                ],
                routeWhileDragging: true,
                show: false,
                addWaypoints: false,
                draggableWaypoints: false,
                fitSelectedRoutes: true,
                createMarker: () => null,
                lineOptions: {
                    styles: [
                        {
                            /*color: '#3498db',
                            color: '#8B4513',*/
                            color: getCSSVariable('--secondary-color'),
                            opacity: 0.8,
                            weight: 5
                        }
                    ]
                }
            }).addTo(map);

        }

        function setupEventListeners() {
            document.querySelector('.overlay').addEventListener('click', closeModal);
            document.getElementById('answerForm').addEventListener('submit', handleFormSubmit);
        }

        function startWatchingPosition() {
            navigator.geolocation.watchPosition(
                position => {
                    userPosition = position;
                    updatePositionMarker(position);
                   // if (routingControl) calculateRoute();
                    calculateRoute();
                },
                error => showToast(`Errore GPS: ${error.message}`),
                { enableHighAccuracy: true }
            );
        }

        function updatePositionMarker(position) {
            const { latitude, longitude } = position.coords;

            if (!currentPositionMarker) {
                currentPositionMarker = L.marker([latitude, longitude], {
                    icon: L.icon({
                        iconUrl: './gps.png?v=1.0.22',
                        iconSize: [32, 32],
                        iconAnchor: [16, 32]
                    })
                }).addTo(map);
            } else {
                currentPositionMarker.setLatLng([latitude, longitude]);
            }
        }

        function updateMap() {
            map.eachLayer(layer => {
                if (layer instanceof L.Marker && layer !== currentPositionMarker) map.removeLayer(layer);
            });

            plaques.forEach(plaque => {
                if (isUnlocked(plaque.id)) {
                    const isFound = userProgress.found.includes(plaque.id);
                    L.marker([plaque.lat, plaque.lng], {
                        icon: L.icon({
                            iconUrl: isFound ?
                                './447147.png?v=1.0.22' : // Icona targa trovata
                                './684908.png?v=1.0.22', // Icona targa da trovare
                            iconSize: [32, 32],
                            iconAnchor: [16, 32]
                        })
                    })
                    .bindPopup(plaque.title)
                    .on('click', () => showPlaque(plaque, plaque.id, isFound))
                    .addTo(map);
                }
            });
        }

        function isUnlocked(id) {
            return userProgress.found.includes(id) ||
                (userProgress.found.length === 0 && id === 1) ||
                (id === userProgress.found[userProgress.found.length - 1] + 1);
        }

        function showPlaque(plaque, id, isFound = false) {
            returnTo360(id, isFound);
          /*  document.getElementById('plaqueImage').src = plaque.image;
            document.getElementById('inputsContainer').innerHTML =
                plaque.missingWords.map(() => '<input type="text" required>').join('');
            document.querySelector('.modal').classList.add('active');
          //  document.querySelector('.overlay').classclassList.add('active');
            document.getElementById('audioPlayer').src = plaque.audio;*/

        }


        function handleFormSubmit(e) {
            e.preventDefault();
            const answers = Array.from(e.target.elements)
                .filter(el => el.tagName === 'INPUT')
                .map(input => input.value.toLowerCase().trim());

            const plaque = plaques.find(p => p.id === userProgress.found.length + 1);
            const valid = validateAnswer(plaque, answers, userPosition);

            if(valid) {
                userProgress.found.push(plaque.id);
                saveProgress();
                //showToast('Risposta corretta!');
                updateMap();
                closeModal();
                showNextLocation();
            }
            showToast(valid ? 'Corretto! Targa sbloccata!' : 'Risposta errata o posizione non corretta');

        }

        function calculateRoute() {

            if (!userPosition) {
                showToast('Attendi il posizionamento GPS...');
                return;
            }

            const nextPlaque = plaques.find(p =>
                !userProgress.found.includes(p.id) && isUnlocked(p.id)
            );

            if (!nextPlaque) {
                showToast('Hai gi√† trovato tutte le targhe!');
                return;
            }


            if (routingControl) {
                console.log('Routing control already exists');
                routingControl.spliceWaypoints(0, 1, L.latLng(userPosition.coords.latitude, userPosition.coords.longitude));
                routingControl.spliceWaypoints(routingControl.getWaypoints().length - 1, 1, L.latLng(nextPlaque.lat, nextPlaque.lng) );
            }else{
               /* routingControl = L.Routing.control({
                    waypoints: [
                        L.latLng(userPosition.coords.latitude, userPosition.coords.longitude),
                        L.latLng(nextPlaque.lat, nextPlaque.lng)
                    ],
                    routeWhileDragging: true,
                    show: false,
                    addWaypoints: false,
                    draggableWaypoints: false,
                    fitSelectedRoutes: true,
                    createMarker: () => null,
                    lineOptions: {
                        styles: [
                            {
                                /*color: '#3498db',
                                color: '#8B4513',* /
                                color: getCSSVariable('--secondary-color'),
                                opacity: 0.8,
                                weight: 5
                            }
                        ]
                    }
                }).addTo(map);*/
            }

            //showToast(`Percorso calcolato per la targa ${nextPlaque.id}`);
        }



        function validateAnswer(plaque, answers, position) {
            const distance = haversineDistance(
                position.coords.latitude,
                position.coords.longitude,
                plaque.lat,
                plaque.lng
            );

            const correctWords = plaque.missingWords
                .map(w => w.toLowerCase())
                .every((w, i) => w === answers[i]);
            return distance <= plaque.radius && correctWords;
        }

        function haversineDistance(lat1, lon1, lat2, lon2) {
            return 10;
            /*const R = 6371e3; // metri
            const œÜ1 = lat1 * Math.PI/180;
            const œÜ2 = lat2 * Math.PI/180;
            const ŒîœÜ = (lat2-lat1) * Math.PI/180;
            const ŒîŒª = (lon2-lon1) * Math.PI/180;

            const a = Math.sin(ŒîœÜ/2) * Math.sin(ŒîœÜ/2) +
                      Math.cos(œÜ1) * Math.cos(œÜ2) *
                      Math.sin(ŒîŒª/2) * Math.sin(ŒîŒª/2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));*/
        }

        function closeModal() {
            document.querySelector('.modal').classList.remove('active');
            document.querySelector('.overlay').classList.remove('active');
        }

        function saveProgress() {
            localStorage.setItem('progress', JSON.stringify(userProgress));
            document.getElementById('counter').textContent = userProgress.found.length;
            updateStatus();
        }

        function resetGame() {
            if (confirm("Sei sicuro di voler resettare il gioco? Tutti i progressi andranno persi!")) {
                if (routingControl) {
                    map.removeControl(routingControl);
                    routingControl = null;
                }
                localStorage.removeItem('progress');
                localStorage.removeItem('tourCompletato');
                userProgress = {found: []};
                updateMap();
                document.getElementById('counter').textContent = 0;
                returnToHome();
            }
            updateStatus();
        }

        function showToast(message, duration = 3000) {
            const toast = document.querySelector('.toast');
            toast.textContent = message;
            toast.style.display = 'block';
            setTimeout(() => toast.style.display = 'none', duration);
        }

        // Inizializza il gioco
        init();

        // Funzioni per gestire la copertina
        function startGame() {
            document.getElementById('welcomeCover').classList.add('hidden');
            /*// Mostra il contenuto del gioco
            document.querySelector('header').style.display = 'block';
            document.getElementById('map').style.display = 'block';
            document.querySelector('.progress-container').style.display = 'flex';*/
            showNextLocation();
        }

        function showInstructions() {
            document.getElementById('instructionsModal').classList.add('active');
        }

        function closeInstructions() {
            document.getElementById('instructionsModal').classList.remove('active');
        }


        function showNextLocation() {
            /*document.querySelector('header').style.display = 'none';*/
            document.getElementById('map').style.display = 'none';
            document.querySelector('.progress-container').style.display = 'none';

            const nextPlaqueId = userProgress.found.length + 1;
            const nextPlaque = plaques.find(p => p.id === nextPlaqueId);


            /*if(nextPlaque.isLastPlaque === true){
                document.querySelector('.location-actions').style.display = 'none';
            }else{
               document.querySelector('.location-actions').style.display = 'flex';
            }*/

            // Assicurati che ci sia una localit√† con immagine 360 disponibile
            if (nextPlaque && nextPlaque.locationImage) {
                display360InLocation(nextPlaque, nextPlaqueId, false, nextPlaque.locationBlurMaskImage);
            }

            // Aggiorna contenuto dinamico
            //document.getElementById('locationImage').style.backgroundImage = `url('${nextPlaque.locationImage}')`;
            document.getElementById('locationTitle').textContent = nextPlaque.locationTitle;
            document.getElementById('locationDescription').innerHTML = nextPlaque.locationDescription;

            document.getElementById('locationScreen').classList.add('active');
            updateMap();
        }

        function startSearch() {
            //document.querySelector('.location-actions').style.display = 'none';
            document.getElementById('locationScreen').classList.remove('active');
            // Mostra elementi del gioco
            /*document.querySelector('header').style.display = 'block';*/
            document.getElementById('map').style.display = 'block';
            document.querySelector('.progress-container').style.display = 'flex';
            setTimeout(() => {
                map.invalidateSize();
            }, 100); // Puoi aggiungere un ritardo se necessario
            calculateRoute();
        }

        function returnToHome() {

            document.getElementById('locationScreen').classList.remove('active');
            document.getElementById('welcomeCover').classList.remove('hidden');
            // Nascondi elementi del gioco
            /*document.querySelector('header').style.display = 'none';*/
            document.getElementById('map').style.display = 'none';
            document.querySelector('.progress-container').style.display = 'none';
            resetButtons();
        }

        function display360InLocation(plaque, id = 0, isFound = false, blurMaskImage = null, blurIntensity = 1.95) {
            const container = document.getElementById('locationImage');

            // Pulisce il contenitore e cancella risorse precedenti
            container.innerHTML = '';

            // Aggiunta: indicatore mobile per dispositivi touch
            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            if (isTouchDevice && !isFound) {
                const touchIndicator = document.createElement('div');
                touchIndicator.className = 'touch-indicator';
                touchIndicator.innerHTML = `
                    <div class="touch-hint">
                        <div class="touch-icon">üëÜ</div>
                        <span>Tocca le aree evidenziate per interagire</span>
                        <div class="touch-swipe-hint">Scorri per esplorare</div>
                    </div>
                `;
                container.appendChild(touchIndicator);

                // Nascondi l'indicatore dopo alcuni secondi
                setTimeout(() => {
                    touchIndicator.style.opacity = '0';
                    setTimeout(() => touchIndicator.style.display = 'none', 1000);
                }, 4000);
            }


            if (container.scene) {
                container.scene.dispose();
            }

            // Inizializza scena, telecamera e renderer
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ alpha: true }); // Attiva trasparenza
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Posiziona la telecamera
            camera.position.z = 0.1;

            // Crea i controlli OrbitControls
            const controls = new THREE.OrbitControls(camera, renderer.domElement);

            // NON usiamo controls.autoRotate, ma implementiamo la rotazione manualmente
            controls.autoRotate = false;

            // Variabili per gestire la rotazione automatica
            let autoRotationEnabled = true;
            const autoRotationSpeed = 0.005; // Aggiusta la velocit√† come necessario (in gradi al secondo)

            // Variabili per l'inerzia
            let rotationVelocity = 0;
            const maxRotationVelocity = 0.3;
            const inertiaFactor = 0.95; // Fattore di smorzamento (tra 0 e 1)
            let lastDeltaX = 0;
            let isInertiaActive = false;

            // Aggiungi gestori di eventi per fermare la rotazione automatica durante il drag
            let userInteracting = false;

            // Altre impostazioni utili
            controls.enableZoom = true;
            controls.zoomSpeed = 1.0;
            controls.enablePan = false; // Disabilita il pan per evitare problemi

            // Limite di inclinazione verticale (opzionale)
            controls.minPolarAngle = Math.PI * 0.1; // Limite superiore (quasi verticale)
            controls.maxPolarAngle = Math.PI * 0.9; // Limite inferiore (quasi verticale)



            // ****** Gestione del cursore ******
            let isDragging = false;
            const setCursor = (type) => {
                container.style.cursor = type;
            };

            // ****** Creazione della Sfera Panorama ******
            const geometry = new THREE.SphereGeometry(500, 60, 40);
            geometry.scale(-1, 1, 1);

            const textureLoader = new THREE.TextureLoader();
            const maskLoader = new THREE.TextureLoader();

            let panoramaMaterial;
            let maskTexture;
            let blurMaskTexture = null;

            // Dichiarazione globale per il materiale della maschera interattiva
            let maskMaterial = undefined;

            // Definizione dei colori per la maschera
            const COLOR_MAGENTA = new THREE.Color(0xff00ff); // Magenta (default lampeggiante)
            const COLOR_GREEN = new THREE.Color(0x00ff00);  // Verde (mouseover)

            // Preparazione per le promise di caricamento
            const loadPromises = [];

            // Promise per caricare la maschera interattiva
            const interactiveMaskPromise = new Promise((resolve, reject) => {
                maskLoader.load(
                    plaque.locationMaskImage,
                    texture => resolve(texture),
                    undefined,
                    error => reject(error)
                );
            });
            loadPromises.push(interactiveMaskPromise);

            // Promise per caricare la maschera per il blur (se specificata)
            let blurMaskPromise = Promise.resolve(null); // Default: nessuna maschera blur
            if (blurMaskImage) {
                blurMaskPromise = new Promise((resolve, reject) => {
                    maskLoader.load(
                        blurMaskImage,
                        texture => resolve(texture),
                        undefined,
                        error => reject(error)
                    );
                });
                loadPromises.push(blurMaskPromise);
            }

            // Promise per caricare la texture a bassa risoluzione
            const lowResPromise = new Promise((resolve, reject) => {
                textureLoader.load(
                    plaque.locationImageLowRes,
                    texture => resolve(texture),
                    undefined,
                    error => reject(error)
                );
            });
            loadPromises.push(lowResPromise);

            // Quando tutte le texture sono caricate, procediamo con la creazione dei materiali
            Promise.all(loadPromises)
                .then(textures => {
                    // Identifica le texture in base all'ordine delle promesse
                    maskTexture = textures[0];

                    let lowResTexture;
                    if (blurMaskImage) {
                        blurMaskTexture = textures[1];
                        lowResTexture = textures[2];
                    } else {
                        lowResTexture = textures[1];
                    }

                    // Crea shader material con supporto al blur basato sulla maschera specifica
                    panoramaMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            panoramaTexture: { value: lowResTexture },
                            blurMaskTexture: { value: blurMaskTexture }, // Pu√≤ essere null
                            useBlurMask: { value: blurMaskTexture !== null },
                            blurStrength: { value: blurIntensity },
                            textureSize: { value: new THREE.Vector2(lowResTexture.image.width, lowResTexture.image.height) }
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform sampler2D panoramaTexture;
                            uniform sampler2D blurMaskTexture;
                            uniform bool useBlurMask;
                            uniform float blurStrength;
                            uniform vec2 textureSize;
                            varying vec2 vUv;
                            
                            vec4 applyBlur(sampler2D tex, vec2 uv, float strength) {
                                // Calcola dimensione pixel per offsets precisi
                                vec2 texelSize = 1.0 / textureSize;
                                
                                // Box blur semplice
                                vec4 result = vec4(0.0);
                                float totalWeight = 0.0;
                                
                                // Dimensione del kernel proporzionale all'intensit√†
                                float radius = strength * 4.0;
                                
                                for (float x = -radius; x <= radius; x += 1.0) {
                                    for (float y = -radius; y <= radius; y += 1.0) {
                                        vec2 offset = vec2(x, y) * texelSize;
                                        result += texture2D(tex, uv + offset);
                                        totalWeight += 1.0;
                                    }
                                }
                                
                                return result / totalWeight;
                            }
                            
                            void main() {
                                // Leggi il colore originale
                                vec4 originalColor = texture2D(panoramaTexture, vUv);
                                
                                if (useBlurMask) {
                                    // Leggi il valore della maschera di blur
                                    vec4 maskColor = texture2D(blurMaskTexture, vUv);
                                    
                                    // Se siamo in un'area bianca della maschera di blur
                                    if (maskColor.r > 0.5) {
                                        // Applica blur con intensit√† proporzionale alla maschera
                                        float blurAmount = maskColor.r * blurStrength;
                                        gl_FragColor = applyBlur(panoramaTexture, vUv, blurAmount);
                                    } else {
                                        // Nessun blur, mostra il colore originale
                                        gl_FragColor = originalColor;
                                    }
                                } else {
                                    // Nessuna maschera di blur, mostra il colore originale ovunque
                                    gl_FragColor = originalColor;
                                }
                            }
                        `
                    });

                    const sphere = new THREE.Mesh(geometry, panoramaMaterial);
                    scene.add(sphere);

                    // Carica texture ad alta risoluzione in background
                    textureLoader.load(plaque.locationImage, (highRes) => {
                        panoramaMaterial.uniforms.panoramaTexture.value = highRes;
                        panoramaMaterial.uniforms.textureSize.value.set(highRes.image.width, highRes.image.height);
                        panoramaMaterial.needsUpdate = true;
                    });

                    // ****** Configurazione della maschera interattiva ******
                    setupInteractiveMask(maskTexture);

                })
                .catch(error => {
                    console.error('Errore durante il caricamento delle texture:', error);
                });

            function setupInteractiveMask(interactiveMaskTexture) {
                const maskImage = document.createElement('canvas');
                const maskImageContext = maskImage.getContext('2d');

                maskImage.width = interactiveMaskTexture.image.width;
                maskImage.height = interactiveMaskTexture.image.height;
                maskImageContext.drawImage(interactiveMaskTexture.image, 0, 0);

                maskMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        maskTexture: { value: interactiveMaskTexture },
                        time: { value: 0 },
                        color: { value: COLOR_MAGENTA.clone() },
                        isMouseOver: { value: 0 },
                    },
                    transparent: true,
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D maskTexture;
                        uniform float time;
                        uniform vec3 color;
                        uniform float isMouseOver;
                        varying vec2 vUv;
        
                        void main() {
                            vec4 maskValue = texture2D(maskTexture, vUv);
                            
                            if (maskValue.r > 0.2) {
                                if (isMouseOver > 0.2) {
                                    gl_FragColor = vec4(color, 0.5);
                                } else {
                                    float alpha = 0.2 + 0.2 * sin(time * 2.0);
                                    gl_FragColor = vec4(color, alpha);
                                }
                            } else {
                                discard;
                            }
                        }
                    `,
                });

                const maskGeometry = new THREE.SphereGeometry(490, 60, 40);
                maskGeometry.scale(-1, 1, 1);
                const mask = new THREE.Mesh(maskGeometry, maskMaterial);

                if (!isFound) {
                    scene.add(mask);
                }

                // ****** Interattivit√† del Mouse e del Touch ******
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();

                container.addEventListener('mousemove', (event) => {
                    if (isDragging) return;

                    if (!isFound) {
                        const rect = container.getBoundingClientRect();
                        mouse.x = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
                        mouse.y = -((event.clientY - rect.top) / container.clientHeight) * 2 + 1;

                        raycaster.setFromCamera(mouse, camera);
                        const intersects = raycaster.intersectObject(mask);

                        if (intersects.length > 0) {
                            const uv = intersects[0].uv;
                            if (uv) {
                                const x = Math.floor(uv.x * maskImage.width);
                                const y = Math.floor((1 - uv.y) * maskImage.height);
                                const pixel = maskImageContext.getImageData(x, y, 1, 1).data;

                                if (pixel[0] > 128 && pixel[1] > 128 && pixel[2] > 128) {
                                    maskMaterial.uniforms.color.value = COLOR_GREEN.clone();
                                    maskMaterial.uniforms.isMouseOver.value = 1;
                                    container.style.cursor = 'pointer';
                                    return;
                                }
                            }
                        }

                        maskMaterial.uniforms.color.value = COLOR_MAGENTA.clone();
                        maskMaterial.uniforms.isMouseOver.value = 0;
                        container.style.cursor = 'move';
                    }
                });

                container.addEventListener('click', function(event) {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObject(mask);

                    if (intersects.length > 0) {
                        const uv = intersects[0].uv;
                        if (uv) {
                            const x = Math.floor(uv.x * maskImage.width);
                            const y = Math.floor((1 - uv.y) * maskImage.height);
                            const pixel = maskImageContext.getImageData(x, y, 1, 1).data;

                            if (pixel[0] > 128 && pixel[1] > 128 && pixel[2] > 128) {

                                // Verifica se l'evento originale era un evento touch
                                 if (isTouch(event)) {
                                    vibrate();
                                }
                                 
                                document.getElementById('plaqueImage').src = plaque.image;
                                document.getElementById('inputsContainer').innerHTML = plaque.missingWords.map((word, idx) =>
                                    `<input type="text" placeholder="parola n. ${idx + 1}" required>`
                                ).join('&nbsp;');
                                document.querySelector('.modal').classList.add('active');
                            }
                        }
                    }
                });
            }

            // ****** Funzione di Animazione ******
            const clock = new THREE.Clock();
            let lon = 0, lat = 0, phi = 0, theta = 0;
            let previousMouseX = 0, previousMouseY = 0;

            function animate() {
                requestAnimationFrame(animate);

                // Aggiorna i controlli (necessario per il damping e lo zoom)
                controls.update();

                // Applica la rotazione automatica se abilitata
                if (autoRotationEnabled && !userInteracting && !isInertiaActive) {
                    // Rotazione automatica normale
                    scene.rotation.y += autoRotationSpeed;
                }
                // Applica l'inerzia se attiva
                else if (isInertiaActive) {
                    // Applica la velocit√† di rotazione attuale
                    scene.rotation.y += rotationVelocity;

                    // Smorza la velocit√† gradualmente
                    rotationVelocity *= inertiaFactor;

                    // Se la velocit√† diventa molto piccola, ferma l'inerzia
                    if (Math.abs(rotationVelocity) < 0.0001) {
                        isInertiaActive = false;
                        // Decidi se riabilitare la rotazione automatica qui
                        // autoRotationEnabled = true; // Opzionale
                    }
                }

                // Aggiorna l'uniforme del tempo per l'effetto lampeggiante sulla maschera
                if (maskMaterial) {
                    maskMaterial.uniforms.time.value = clock.getElapsedTime();
                }

                phi = THREE.MathUtils.degToRad(90 - lat);
                theta = THREE.MathUtils.degToRad(lon);

                camera.lookAt(
                    500 * Math.sin(phi) * Math.cos(theta),
                    500 * Math.cos(phi),
                    500 * Math.sin(phi) * Math.sin(theta)
                );

                renderer.render(scene, camera);
            }
            animate();

            // ****** Eventi di Rotazione e Zoom (Mouse + Touch) ******
            container.addEventListener('wheel', (event) => {
                event.preventDefault();
                camera.fov += event.deltaY * 0.05;
                camera.fov = Math.max(10, Math.min(75, camera.fov));
                camera.updateProjectionMatrix();
            });
            container.addEventListener('mouseenter', () => {
                if (!isDragging) setCursor('move');
            });

            container.addEventListener('mousedown', (event) => {
                isDragging = true;
                autoRotationEnabled = false;
                userInteracting = true;
                setCursor('grabbing');

                previousMouseX = event.clientX;
                previousMouseY = event.clientY;
            });

            container.addEventListener('mousemove', (event) => {
                if (isDragging) {
                    const deltaX = event.clientX - previousMouseX;
                    const deltaY = event.clientY - previousMouseY;

                    // Salva deltaX per il calcolo dell'inerzia
                    lastDeltaX = deltaX;


                    lon -= deltaX * 0.1;
                    lat += deltaY * 0.1;
                    lat = Math.max(-85, Math.min(85, lat));
                    previousMouseX = event.clientX;
                    previousMouseY = event.clientY;
                    setCursor('grabbing');
                }

            });

            container.addEventListener('mouseup', () => {
                userInteracting = false;
                // Non riattiva la rotazione automatica
                isDragging = false;

                // Calcola la velocit√† di rotazione in base all'ultimo movimento
                rotationVelocity = -lastDeltaX * 0.0005; // Scala appropriatamente

                // Limita la velocit√† massima
                rotationVelocity = Math.max(-maxRotationVelocity, Math.min(maxRotationVelocity, rotationVelocity));

                // Attiva l'inerzia solo se c'√® abbastanza velocit√†
                isInertiaActive = Math.abs(rotationVelocity) > 0.0005;

                setCursor('move');
            });

            container.addEventListener('mouseleave', () => {
                isDragging = false;
                setCursor('move');
            });

            // Variabili per gestire il pinch-to-zoom
            let initialPinchDistance = 0;
            let isPinching = false;

            container.addEventListener('touchstart', (event) => {
                autoRotationEnabled = false;
                userInteracting = true;

                // Controlla se stiamo iniziando un pinch zoom (2 dita)
                if (event.touches.length === 2) {
                    isPinching = true;

                    // Calcola la distanza iniziale tra le due dita
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];
                    initialPinchDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );
                }
                // Altrimenti √® una rotazione normale con una sola dita
                else if (event.touches.length === 1) {
                    isDragging = true;
                    previousMouseX = event.touches[0].clientX;
                    previousMouseY = event.touches[0].clientY;
                }
            });

            container.addEventListener('touchmove', (event) => {
                event.preventDefault(); // Previene lo scrolling della pagina

                // Gestisci il pinch-to-zoom con due dita
                if (isPinching && event.touches.length === 2) {
                    const touch1 = event.touches[0];
                    const touch2 = event.touches[1];

                    // Calcola la distanza attuale tra le dita
                    const currentPinchDistance = Math.hypot(
                        touch2.clientX - touch1.clientX,
                        touch2.clientY - touch1.clientY
                    );

                    // Calcola il fattore di zoom
                    const pinchDelta = currentPinchDistance - initialPinchDistance;

                    // Applica lo zoom
                    camera.fov -= pinchDelta * 0.35; // Regola la sensibilit√† qui
                    camera.fov = Math.max(10, Math.min(75, camera.fov)); // Limita lo zoom
                    camera.updateProjectionMatrix();

                    // Aggiorna la distanza iniziale per il prossimo movimento
                    initialPinchDistance = currentPinchDistance;
                }
                // Gestisci la rotazione normale con un dito
                else if (isDragging && event.touches.length === 1) {
                    const deltaX = event.touches[0].clientX - previousMouseX;
                    const deltaY = event.touches[0].clientY - previousMouseY;

                    // Salva deltaX per il calcolo dell'inerzia
                    lastDeltaX = deltaX;

                    lon -= deltaX * 0.1;
                    lat += deltaY * 0.1;
                    lat = Math.max(-85, Math.min(85, lat));
                    previousMouseX = event.touches[0].clientX;
                    previousMouseY = event.touches[0].clientY;
                }
            }, { passive: false }); // Importante: passive: false consente di chiamare preventDefault()

            container.addEventListener('touchend', (event) => {
                userInteracting = false;

                // Se c'era un pinch in corso
                if (isPinching) {
                    isPinching = false;
                    // Se rimane un dito, torna in modalit√† rotazione
                    if (event.touches.length === 1) {
                        isDragging = true;
                        previousMouseX = event.touches[0].clientX;
                        previousMouseY = event.touches[0].clientY;
                    } else {
                        isDragging = false;
                    }
                }
                // Se era una rotazione
                else if (isDragging) {
                    isDragging = false;

                    // Calcola l'inerzia solo se era rotazione (non zoom)
                    if (!isPinching) {
                        // Calcola la velocit√† di rotazione in base all'ultimo movimento touch
                        rotationVelocity = -lastDeltaX * 0.005; // Scala appropriatamente

                        // Limita la velocit√† massima
                        rotationVelocity = Math.max(-maxRotationVelocity, Math.min(maxRotationVelocity, rotationVelocity));

                        // Attiva l'inerzia solo se c'√® abbastanza velocit√†
                        isInertiaActive = Math.abs(rotationVelocity) > 0.005;
                    }
                }
            });

            // Aggiungi anche un gestore per touchcancel
            container.addEventListener('touchcancel', () => {
                userInteracting = false;
                isDragging = false;
                isPinching = false;
            });


            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }


        function returnTo360(id = 0, isFound = false) {
            // Nascondi la mappa
            document.getElementById('map').style.display = 'none';
            document.querySelector('.progress-container').style.display = 'none';

            // Mostra la schermata di 360 gradi
            const locationScreen = document.getElementById('locationScreen');
            locationScreen.classList.add('active');
            let plaqueId = 0;
            if(id !== 0){
                plaqueId = id;
            }else{
                plaqueId = userProgress.found.length + 1;
            }

            // Mostra la foto 360¬∞
            const currentPlaque = plaques.find(p => p.id === plaqueId);

            let locationMask = currentPlaque.locationBlurMaskImage;
            if(isFound){
                locationMask = currentPlaque.locationBlurMaskSolvedImage;
            }
            if (currentPlaque && currentPlaque.locationImage) {
                document.getElementById('locationTitle').textContent = currentPlaque.locationTitle;
                document.getElementById('locationDescription').innerHTML = currentPlaque.locationDescription;

                display360InLocation(currentPlaque, plaqueId, isFound, locationMask);
            }
        }

        function updateStatus(){
            document.getElementById('counter_progress').innerHTML = userProgress.found.length;
            document.getElementById('of_counter_progress').innerHTML = plaques.length - 1;
        }

        // Funzione per impostare il tema
        function setTheme(themeName) {
            if(themeName === 'vintage') {
                document.documentElement.setAttribute('data-theme', 'vintage');
            } else if(themeName === 'grazia_deledda') {
                document.documentElement.setAttribute('data-theme', 'grazia_deledda');
            } else if(themeName === 'may') {
                document.documentElement.setAttribute('data-theme', 'may');
            } else if(themeName === 'july') {
                document.documentElement.setAttribute('data-theme', 'july');
            } else if(themeName === 'moderno') {
                document.documentElement.setAttribute('data-theme', 'moderno');
            } else {
                document.documentElement.removeAttribute('data-theme');
            }



            // Salva la preferenza
            localStorage.setItem('selectedTheme', themeName);
        }


        // Nascondi elementi del gioco all'avvio
        document.addEventListener('DOMContentLoaded', () => {
            /*document.querySelector('header').style.display = 'none';*/
            document.getElementById('map').style.display = 'none';
            document.querySelector('.progress-container').style.display = 'none';

        });

        // Carica il tema salvato all'avvio
        window.addEventListener('DOMContentLoaded', () => {
            /*const savedTheme = localStorage.getItem('selectedTheme') || 'grazia_deledda';
            setTheme(savedTheme);*/
            setTheme('grazia_deledda');

            updateStatus();

            // Assicuriamoci che il div location-content non interferisca con il drag della foto 360
            document.addEventListener('DOMContentLoaded', function () {
                const locationContent = document.querySelector('.location-content');

                if (locationContent) {
                    // Aggiungiamo un evento che impedisce la propagazione degli eventi di mouse sul location-content
                    locationContent.addEventListener('mousedown', function (e) {
                        // Controlla se l'elemento cliccato √® un pulsante o un suo discendente
                        if (!e.target.closest('.location-actions button')) {
                            // Preveniamo il comportamento predefinito e la propagazione solo se non √® un pulsante
                            e.preventDefault();
                            // Non fermiamo la propagazione, cos√¨ l'evento arriva comunque alla foto 360
                        }
                    });

                    // Facciamo anche in modo che gli eventi di touch funzionino allo stesso modo
                    locationContent.addEventListener('touchstart', function (e) {
                        if (!e.target.closest('.location-actions button')) {
                            e.preventDefault();
                        }
                    });

                    // Assicuriamoci che il contenuto non sia selezionabile
                    locationContent.style.userSelect = 'none';
                    locationContent.style.webkitUserSelect = 'none';
                    locationContent.style.msUserSelect = 'none';
                    locationContent.style.mozUserSelect = 'none';

                    // Facciamo in modo che i pulsanti siano cliccabili
                    const buttons = locationContent.querySelectorAll('.location-actions button');
                    buttons.forEach(button => {
                        button.style.pointerEvents = 'auto';
                    });
                }

            });

        });